// Generated by CoffeeScript 1.6.2
(function() {
  var StumpLog, colors, defaults, dummyinspect, extend, fs, genericinspect, glocount, isnode, merge, obj_for_display, type_to_string, util,
    __hasProp = {}.hasOwnProperty,
    _this = this,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __slice = [].slice;

  isnode = require('isnode');

  extend = function(object, properties) {
    var key, val;

    for (key in properties) {
      if (!__hasProp.call(properties, key)) continue;
      val = properties[key];
      object[key] = val;
    }
    return object;
  };

  merge = function(options, overrides) {
    return extend(extend({}, options), overrides);
  };

  type_to_string = function(obj) {
    var classToType, myClass, name, _i, _len, _ref;

    if (obj === void 0 || obj === null) {
      return String(obj);
    }
    classToType = new Object;
    _ref = "Boolean Number String Function Array Date RegExp".split(" ");
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      name = _ref[_i];
      classToType["[object " + name + "]"] = name.toLowerCase();
    }
    myClass = Object.prototype.toString.call(obj);
    if (myClass in classToType) {
      return classToType[myClass];
    }
    return "object";
  };

  glocount = 0;

  dummyinspect = function(arg1) {
    return arg1;
  };

  genericinspect = dummyinspect;

  colors = require('enkicolor');

  if (isnode) {
    fs = require('fs');
    util = require('util');
    genericinspect = function(arg) {
      return util.inspect(arg, false, 6, true);
    };
  } else {

  }

  defaults = {
    delimiter: '-',
    delimiterColor: 'green',
    levels: {
      trace: 'grey',
      debug: 'cyan',
      info: 'green',
      warn: 'yellow',
      error: 'red',
      line: 'bold',
      zalgo: 'magenta'
    },
    prefixCol: 'blue',
    dateCol: 'grey',
    suppress: {
      TRACE: false,
      DEBUG: false
    },
    suppress_start: {
      TRACE: [],
      DEBUG: []
    },
    LOGCHANNELS: {
      'default': ['console']
    },
    logchan: 'default'
  };

  obj_for_display = function(obj, context, myinspect) {
    var elem, i, key, processq, tmpcnt, typ, val, _i, _len;

    context = context || {};
    if (context.final == null) {
      context.final = true;
    }
    if (!isnode) {
      return obj;
    }
    context.seenbook = context.seenbook || [];
    typ = type_to_string(obj);
    processq = null;
    if (typ === 'object' || typ === 'function') {
      if (obj instanceof Error) {
        return obj;
      }
      if (__indexOf.call(context.seenbook, obj) >= 0) {
        return '<CIRCULAR>';
      }
      context.seenbook.push(obj);
      if (obj._refid) {
        typ = 'ref';
        processq = '<REF ' + obj.get_refpath().join('/') + '>';
      } else {
        processq = {};
        tmpcnt = 0;
        for (key in obj) {
          val = obj[key];
          tmpcnt += 1;
          if (!(context.skipunderscore && key.indexOf('_') === 0)) {
            processq[key] = obj_for_display(val, merge(context, {
              final: false
            }), myinspect);
          }
        }
        if (tmpcnt === 0) {
          processq = obj;
        }
      }
    } else if (typ === 'array') {
      processq = [];
      for (i = _i = 0, _len = obj.length; _i < _len; i = ++_i) {
        elem = obj[i];
        processq.push(obj_for_display(elem, merge(context, {
          final: false
        }), myinspect));
      }
    } else if (typ === 'undefined') {
      return void 0;
    } else if (typ === 'null') {
      return null;
    } else {
      return obj;
    }
    if (!context.final) {
      return processq;
    } else {
      return myinspect(processq, false, 6, true);
    }
  };

  StumpLog = (function() {
    function StumpLog(desc_callback, custom, parent, root) {
      var key, val, _ref;

      this.parent = parent;
      this.root = root;
      this.stumpify = __bind(this.stumpify, this);
      this.suppress = __bind(this.suppress, this);
      this.sub = __bind(this.sub, this);
      this._prep_log_console = __bind(this._prep_log_console, this);
      this._log = __bind(this._log, this);
      this.log = __bind(this.log, this);
      this.root = this.root || this.parent || this;
      custom = custom || {};
      this.config = merge(defaults, custom);
      this.desc_callback = desc_callback || function() {
        return '';
      };
      if (type_to_string(this.desc_callback) !== 'function') {
        this.desc_callback = function() {
          return desc_callback;
        };
      }
      _ref = this.config.levels;
      for (key in _ref) {
        val = _ref[key];
        this[key] = this._log.bind(this, key);
      }
    }

    StumpLog.prototype.log = function() {
      var args;

      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      return this.info.apply(this, args);
    };

    StumpLog.prototype._log = function() {
      var args, chan, colormsg, lchans, level, nocolors, _i, _len, _results,
        _this = this;

      level = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      lchans = this.config.LOGCHANNELS[this.config.logchan];
      colormsg = this._prep_log_console.apply(this, [colors, genericinspect, level].concat(__slice.call(args)));
      nocolors = {
        green: function(a) {
          return a;
        },
        grey: function(a) {
          return a;
        },
        blue: function(a) {
          return a;
        },
        bold: function(a) {
          return a;
        },
        red: function(a) {
          return a;
        },
        cyan: function(a) {
          return a;
        }
      };
      glocount += 1;
      _results = [];
      for (_i = 0, _len = lchans.length; _i < _len; _i++) {
        chan = lchans[_i];
        if (!chan) {
          continue;
        }
        if (chan === 'console') {
          _results.push(console.log.apply(console, colormsg));
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    StumpLog.prototype._prep_log_console = function() {
      var arg, args, delim, desc, dtmp, elem, level, level_suppress, logmsg, mycolors, myinspect, x, _i, _j, _k, _len, _len1, _len2, _ref;

      mycolors = arguments[0], myinspect = arguments[1], level = arguments[2], args = 4 <= arguments.length ? __slice.call(arguments, 3) : [];
      if (this.config.suppress[level.toUpperCase()]) {
        return;
      }
      level_suppress = this.root.config.suppress_start[level.toUpperCase()] || [];
      desc = this.desc_callback();
      for (_i = 0, _len = level_suppress.length; _i < _len; _i++) {
        x = level_suppress[_i];
        if (desc.indexOf(x) >= 0) {
          return;
        }
      }
      delim = mycolors[this.config.delimiterColor](this.config.delimiter);
      dtmp = new Date();
      logmsg = [mycolors[this.config.dateCol](dtmp.toLocaleTimeString() + '.' + dtmp.getMilliseconds()), delim, mycolors[this.config['levels'][level]](level.toUpperCase()), delim];
      _ref = this.get_logchain();
      for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
        elem = _ref[_j];
        logmsg.push(mycolors.bold(mycolors[this.config['prefixCol']](elem)));
        logmsg.push(delim);
      }
      for (_k = 0, _len2 = args.length; _k < _len2; _k++) {
        arg = args[_k];
        if (arg === null) {
          arg = '[null]';
        }
        if (arg === void 0) {
          arg = '[undefined]';
        }
        logmsg.push(mycolors[this.config['levels'][level]](obj_for_display(arg, {}, myinspect)));
      }
      return logmsg;
    };

    StumpLog.prototype.get_logchain = function() {
      var coll, tmp, x;

      x = this;
      coll = [];
      while (x) {
        tmp = (typeof x.desc_callback === "function" ? x.desc_callback() : void 0) || x.desc_callback;
        if (tmp && tmp.length > 0) {
          coll.push(tmp);
        }
        x = x.parent;
      }
      return coll.reverse();
    };

    StumpLog.prototype.sub = function(desc_callback) {
      var sublog;

      sublog = new StumpLog(desc_callback, this.config, this, this.root);
      return sublog;
    };

    StumpLog.prototype.suppress = function(level) {
      return this.config.suppress[level.toUpperCase()] = true;
    };

    StumpLog.prototype.stumpify = function(target, desc_callback) {
      var key, sublog, val, _ref;

      sublog = this.sub(desc_callback);
      _ref = sublog.config.levels;
      for (key in _ref) {
        val = _ref[key];
        target[key] = sublog[key];
      }
      target.stumpify = sublog.stumpify;
      target.log = sublog.log;
      return target._stump = sublog;
    };

    return StumpLog;

  })();

  module.exports = new StumpLog();

  module.exports.StumpLog = StumpLog;

  module.exports.obj_for_display = obj_for_display;

}).call(this);
